<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Data Fetching Patterns</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
</head>

<body class="bg-gradient-to-br from-gray-100 to-gray-200 min-h-screen font-sans leading-relaxed text-gray-800">

  <!-- Header -->
  <header class="sticky top-0 z-50 bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow-lg py-6 text-center">
    <h1 class="text-3xl font-bold animate-pulse mb-2">üîÑ API Data Fetching Patterns</h1>
    <p class="text-base font-medium opacity-90">Comprehensive summary from Educative.io</p>
  </header>

  <!-- Main content -->
  <main class="pt-10 px-6 max-w-6xl mx-auto space-y-10">

    <!-- Section: Overview -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üìö <span>Overview</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>Data fetching patterns define how clients interact with APIs to retrieve data efficiently and scalably.</li>
        <li>Choosing the right pattern can minimize latency, reduce over-fetching/under-fetching, and improve overall
          user experience.</li>
        <li>The three most common API data fetching patterns are:
          <ul class="list-decimal pl-6 mt-2 space-y-1">
            <li><strong>Request-Response</strong></li>
            <li><strong>Streaming</strong></li>
            <li><strong>Subscription (Publish-Subscribe)</strong></li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- Section: 1. Request-Response Pattern -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üí¨ <span>1. Request-Response Pattern</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>The most common and traditional pattern in web APIs (REST, GraphQL, gRPC, etc.).</li>
        <li>The client sends a request; the server processes it and returns a response with the requested data.</li>
        <li>
          <strong>Advantages:</strong>
          <ul class="list-disc pl-6">
            <li>Simple and widely understood</li>
            <li>Suitable for most CRUD operations</li>
            <li>Easier to debug and trace</li>
          </ul>
        </li>
        <li>
          <strong>Limitations:</strong>
          <ul class="list-disc pl-6">
            <li>Inefficient for real-time scenarios (e.g., chat, stock ticker)</li>
            <li>Not ideal for large or continuously changing datasets</li>
          </ul>
        </li>
        <li>
          <strong>Example:</strong> Client sends a GET request to fetch a user profile, receives a single JSON object in
          response.
        </li>
      </ul>
    </section>

    <!-- Section: 2. Streaming Pattern -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üåä <span>2. Streaming Pattern</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>Server sends data to the client as a continuous stream, instead of a single response.</li>
        <li>Can be unidirectional (server to client) or bidirectional (both ways), supported in protocols like HTTP/2,
          gRPC, and WebSockets.</li>
        <li>
          <strong>Use cases:</strong>
          <ul class="list-disc pl-6">
            <li>Large datasets (logs, analytics results)</li>
            <li>Progressive delivery (loading chunks of video, large files)</li>
            <li>Real-time feeds</li>
          </ul>
        </li>
        <li>
          <strong>Advantages:</strong>
          <ul class="list-disc pl-6">
            <li>Reduces memory usage for large data</li>
            <li>Lower latency for the first chunk of data</li>
            <li>Can support live updates</li>
          </ul>
        </li>
        <li>
          <strong>Challenges:</strong>
          <ul class="list-disc pl-6">
            <li>Client must handle partial data and end-of-stream signals</li>
            <li>More complex error handling</li>
            <li>Can be harder to implement and test</li>
          </ul>
        </li>
        <li>
          <strong>Example:</strong> Video streaming platforms deliver video data in small chunks as the user watches.
        </li>
      </ul>
    </section>

    <!-- Section: 3. Subscription (Publish-Subscribe) Pattern -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üì¢ <span>3. Subscription (Publish-Subscribe) Pattern</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>The client subscribes to specific events or data updates and receives push notifications from the server
          when relevant data changes.</li>
        <li>Common in WebSockets, GraphQL Subscriptions, and message brokers (e.g., MQTT, Kafka).</li>
        <li>
          <strong>Use cases:</strong>
          <ul class="list-disc pl-6">
            <li>Chat applications</li>
            <li>Live dashboards</li>
            <li>Collaborative tools (e.g., Google Docs)</li>
          </ul>
        </li>
        <li>
          <strong>Advantages:</strong>
          <ul class="list-disc pl-6">
            <li>Real-time updates to clients</li>
            <li>Efficient: only changed data is sent</li>
            <li>Low client polling overhead</li>
          </ul>
        </li>
        <li>
          <strong>Challenges:</strong>
          <ul class="list-disc pl-6">
            <li>Connection management (keep-alive, reconnection)</li>
            <li>Security and access control</li>
            <li>Scaling with many concurrent clients</li>
          </ul>
        </li>
        <li>
          <strong>Example:</strong> User receives real-time notifications in a social media app when someone likes their
          post.
        </li>
      </ul>
    </section>

    <!-- Section: Choosing a Pattern -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        ‚öñÔ∏è <span>Choosing the Right Data Fetching Pattern</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>No one-size-fits-all; the choice depends on use case, scale, and user experience requirements.</li>
        <li>
          <strong>Guidelines:</strong>
          <ul class="list-disc pl-6">
            <li>Use <b>request-response</b> for simple CRUD and infrequent data needs.</li>
            <li>Use <b>streaming</b> for large/continuous datasets or when progressive rendering is needed.</li>
            <li>Use <b>subscription</b> for real-time collaboration, notifications, or live data dashboards.</li>
          </ul>
        </li>
        <li>Mixing patterns in the same application is common (e.g., use request-response for most data, and
          subscriptions for live updates).</li>
        <li>Always consider scalability, client complexity, and error handling when selecting a pattern.</li>
      </ul>
    </section>

    <!-- Section: Pub/Sub vs WebSocket -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üîó <span>Comparison: Pub/Sub vs WebSocket</span>
      </h2>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm border border-gray-200">
          <thead>
            <tr class="bg-gradient-to-r from-blue-100 to-indigo-100 text-gray-800">
              <th class="py-2 px-4 font-bold text-left border-b border-gray-200">Aspect</th>
              <th class="py-2 px-4 font-bold text-left border-b border-gray-200">Pub/Sub</th>
              <th class="py-2 px-4 font-bold text-left border-b border-gray-200">WebSocket</th>
            </tr>
          </thead>
          <tbody class="bg-white">
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Definition</td>
              <td class="py-2 px-4 border-b border-gray-100">A messaging pattern where publishers send messages to
                topics, and subscribers receive messages for topics they're interested in, often via a broker (e.g.,
                Kafka, MQTT).</td>
              <td class="py-2 px-4 border-b border-gray-100">A protocol providing full-duplex, persistent communication
                between client and server over a single TCP connection.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Architecture</td>
              <td class="py-2 px-4 border-b border-gray-100">Decoupled: publishers and subscribers do not communicate
                directly; use a broker as intermediary.</td>
              <td class="py-2 px-4 border-b border-gray-100">Direct: client and server communicate directly via an open
                connection.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Scalability</td>
              <td class="py-2 px-4 border-b border-gray-100">Highly scalable; brokers can handle millions of topics and
                subscribers.</td>
              <td class="py-2 px-4 border-b border-gray-100">Limited by server's ability to maintain concurrent open
                connections.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Typical Use Cases</td>
              <td class="py-2 px-4 border-b border-gray-100">IoT, event-driven microservices, log aggregation,
                notification systems.</td>
              <td class="py-2 px-4 border-b border-gray-100">Chat apps, collaborative tools, live dashboards, online
                games.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Message Routing</td>
              <td class="py-2 px-4 border-b border-gray-100">By topic; broker routes messages to interested subscribers.
              </td>
              <td class="py-2 px-4 border-b border-gray-100">No built-in routing; application must handle message
                distribution.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Reliability & Delivery Guarantees</td>
              <td class="py-2 px-4 border-b border-gray-100">Supports at-least-once/at-most-once/exactly-once delivery
                (depends on broker).</td>
              <td class="py-2 px-4 border-b border-gray-100">No delivery guarantees by default; must be implemented at
                app level.</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Protocol</td>
              <td class="py-2 px-4 border-b border-gray-100">Usually TCP-based (e.g., MQTT, AMQP, Kafka), sometimes
                HTTP-based.</td>
              <td class="py-2 px-4 border-b border-gray-100">WebSocket protocol (ws:// or wss://).</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Example Stack</td>
              <td class="py-2 px-4 border-b border-gray-100">Kafka, RabbitMQ, Google Pub/Sub, AWS SNS/SQS</td>
              <td class="py-2 px-4 border-b border-gray-100">Socket.io, native WebSocket API, SignalR</td>
            </tr>
            <tr>
              <td class="py-2 px-4 border-b border-gray-100">Persistence</td>
              <td class="py-2 px-4 border-b border-gray-100">Supports message persistence, replay, and storage (depends
                on broker).</td>
              <td class="py-2 px-4 border-b border-gray-100">No built-in persistence; ephemeral unless implemented
                manually.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <ul class="mt-6 list-disc pl-6 space-y-1 text-gray-700">
        <li><b>Pub/Sub</b> is best for decoupling producers and consumers, building scalable, event-driven
          architectures, and when message replay or persistence is needed.</li>
        <li><b>WebSocket</b> excels for low-latency, bi-directional, direct communication, such as chat apps or
          collaborative UIs.</li>
        <li>They are not mutually exclusive: a system can use WebSockets for client communication and Pub/Sub internally
          for backend scalability.</li>
      </ul>
    </section>

    <!-- Section: When to Use Pub/Sub vs WebSocket? (AWS Context) -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        ü§î <span>When to Use Pub/Sub vs WebSocket? (Especially in AWS Systems)</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li>
          <b>Use Pub/Sub when:</b>
          <ul class="list-disc pl-6">
            <li>You need to decouple microservices or components.</li>
            <li>You have many producers and consumers, and want to fan out messages efficiently.</li>
            <li>You need message durability, replay, or guaranteed delivery.</li>
            <li>You build event-driven, serverless architectures (e.g., AWS Lambda triggers from SNS/SQS).</li>
            <li>Examples: order processing, notification systems, IoT data ingestion.</li>
          </ul>
        </li>
        <li>
          <b>Use WebSocket when:</b>
          <ul class="list-disc pl-6">
            <li>You require real-time, two-way, low-latency communication between client and server.</li>
            <li>You are building interactive applications: chat, live games, collaborative editing, real-time
              dashboards.</li>
            <li>You need to push updates instantly from server to browser/app and vice versa.</li>
            <li>Connection state or direct session management is important.</li>
          </ul>
        </li>
        <li>
          <b>In AWS Architectures:</b>
          <ul class="list-disc pl-6">
            <li>
              For <b>Pub/Sub</b>:
              <ul class="list-disc pl-6">
                <li>Use <b>AWS SNS</b> (Simple Notification Service) for topic-based publish/subscribe, and <b>AWS
                    SQS</b> (Simple Queue Service) for queue-based messaging and decoupling.</li>
                <li>For high-throughput and persistence, use <b>Amazon Kinesis</b> or <b>Amazon MSK (Managed Kafka)</b>.
                </li>
                <li>Connect to serverless (Lambda), EC2, containers, or other services as subscribers.</li>
              </ul>
            </li>
            <li>
              For <b>WebSocket</b>:
              <ul class="list-disc pl-6">
                <li>Use <b>AWS API Gateway WebSocket API</b> for managed, scalable WebSocket endpoints.</li>
                <li>Integrate with AWS Lambda for backend processing, or manage connections with AWS services.</li>
                <li>Good for chat, notifications, collaborative features where client needs persistent connection.</li>
              </ul>
            </li>
            <li>
              <b>Best practice: Combine both!</b>
              <ul class="list-disc pl-6">
                <li>WebSocket can handle live client-server communication.</li>
                <li>Pub/Sub can handle backend fan-out, persistence, and system integration.</li>
                <li>
                  <span class="italic">Example:</span> For a chat app on AWS, use API Gateway WebSocket for client chat
                  connections, but SNS/SQS or Kinesis to broadcast messages to other services, store chat history, or
                  trigger analytics.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <b>Summary Table:</b>
          <div class="overflow-x-auto mt-2">
            <table class="min-w-full text-sm border border-gray-200">
              <thead>
                <tr class="bg-gradient-to-r from-blue-50 to-indigo-50 text-gray-800">
                  <th class="py-2 px-4 font-bold text-left border-b border-gray-200">Scenario</th>
                  <th class="py-2 px-4 font-bold text-left border-b border-gray-200">Recommended Pattern (AWS)</th>
                </tr>
              </thead>
              <tbody class="bg-white">
                <tr>
                  <td class="py-2 px-4 border-b border-gray-100">Decoupled event-driven system, microservices,
                    notifications</td>
                  <td class="py-2 px-4 border-b border-gray-100">Pub/Sub (SNS, SQS, Kinesis)</td>
                </tr>
                <tr>
                  <td class="py-2 px-4 border-b border-gray-100">Real-time chat, collaborative app, dashboard</td>
                  <td class="py-2 px-4 border-b border-gray-100">WebSocket (API Gateway WebSocket API)</td>
                </tr>
                <tr>
                  <td class="py-2 px-4 border-b border-gray-100">Real-time client updates + durable backend event
                    processing</td>
                  <td class="py-2 px-4 border-b border-gray-100">Combine WebSocket for frontend, Pub/Sub for backend
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </li>
      </ul>
      <div class="mt-6 text-gray-700">
        <b>Key advice:</b>
        <ul class="list-disc pl-6 mt-2">
          <li>WebSocket ‚â† Pub/Sub: They solve different problems; often, you need both for a robust, scalable solution.
          </li>
          <li>Always design for scalability and maintainability‚Äîleverage AWS managed services where possible.</li>
        </ul>
      </div>
    </section>

    <!-- Section: Visual Model of Pub/Sub vs WebSocket -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üñºÔ∏è <span>Visual Model: Pub/Sub vs WebSocket</span>
      </h2>
      <div class="grid md:grid-cols-2 gap-8">
        <!-- Pub/Sub Model -->
        <div>
          <h3 class="font-bold text-lg mb-3 flex items-center gap-2">üì¨ Pub/Sub Model</h3>
          <div class="relative flex flex-col items-center">
            <!-- Publisher -->
            <div class="flex flex-col items-center mb-4">
              <div class="rounded-full bg-blue-500 text-white px-4 py-2 shadow-md mb-1">Publisher(s)</div>
              <div class="w-1 h-10 bg-blue-300"></div>
            </div>
            <!-- Broker (Topic) -->
            <div class="rounded-lg bg-yellow-400 text-gray-900 px-8 py-2 shadow-lg font-semibold mb-1">Broker / Topic
            </div>
            <svg height="40" width="80" class="my-2">
              <line x1="40" y1="0" x2="0" y2="40" style="stroke: #fbbf24; stroke-width:3" />
              <line x1="40" y1="0" x2="80" y2="40" style="stroke: #fbbf24; stroke-width:3" />
            </svg>
            <!-- Subscribers -->
            <div class="flex gap-4 mt-2">
              <div class="rounded-full bg-green-500 text-white px-4 py-2 shadow-md">Subscriber A</div>
              <div class="rounded-full bg-green-400 text-white px-4 py-2 shadow-md">Subscriber B</div>
              <div class="rounded-full bg-green-300 text-white px-4 py-2 shadow-md">Subscriber C</div>
            </div>
          </div>
          <div class="text-gray-700 text-sm mt-4">
            <b>Flow:</b> Publishers send messages to a Broker (Topic). Subscribers receive messages from the Broker
            based on their subscription.
          </div>
        </div>
        <!-- WebSocket Model -->
        <div>
          <h3 class="font-bold text-lg mb-3 flex items-center gap-2">üîå WebSocket Model</h3>
          <div class="relative flex flex-col items-center">
            <!-- Server -->
            <div class="rounded-lg bg-indigo-600 text-white px-8 py-2 shadow-lg font-semibold mb-2">WebSocket Server
            </div>
            <svg height="40" width="80" class="my-2">
              <line x1="40" y1="40" x2="0" y2="0" style="stroke: #6366f1; stroke-width:3" />
              <line x1="40" y1="40" x2="80" y2="0" style="stroke: #6366f1; stroke-width:3" />
            </svg>
            <!-- Clients -->
            <div class="flex gap-4">
              <div class="rounded-full bg-pink-400 text-white px-4 py-2 shadow-md">Client 1</div>
              <div class="rounded-full bg-pink-500 text-white px-4 py-2 shadow-md">Client 2</div>
              <div class="rounded-full bg-pink-600 text-white px-4 py-2 shadow-md">Client 3</div>
            </div>
            <div class="absolute left-1/2 -translate-x-1/2 bottom-[78px] z-10">
              <svg width="80" height="40">
                <line x1="0" y1="20" x2="80" y2="20" style="stroke-dasharray:4 4;stroke:#6366f1;stroke-width:2" />
              </svg>
            </div>
          </div>
          <div class="text-gray-700 text-sm mt-4">
            <b>Flow:</b> Clients establish direct, persistent two-way connections with the WebSocket server. Data can
            flow in both directions.
          </div>
        </div>
      </div>
      <div class="mt-6 text-gray-700 text-sm">
        <b>Legend:</b> <span class="inline-block rounded-full bg-blue-500 w-4 h-4 align-middle"></span> Publisher |
        <span class="inline-block rounded-lg bg-yellow-400 w-4 h-4 align-middle"></span> Broker |
        <span class="inline-block rounded-full bg-green-500 w-4 h-4 align-middle"></span> Subscriber |
        <span class="inline-block rounded-lg bg-indigo-600 w-4 h-4 align-middle"></span> WebSocket Server |
        <span class="inline-block rounded-full bg-pink-500 w-4 h-4 align-middle"></span> Client
      </div>
    </section>

    <!-- Section: Senior/Lead Notes -->
    <section class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
        üèÜ <span>Senior/Lead Engineer Notes</span>
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        <li><strong>Assess trade-offs:</strong> Each pattern comes with unique performance, scalability, and
          maintainability implications. Be proactive in weighing simplicity versus flexibility.</li>
        <li><strong>Client experience matters:</strong> Monitor how the chosen pattern impacts perceived latency,
          responsiveness, and data freshness for end users.</li>
        <li><strong>Design for extensibility:</strong> Abstract your data access logic so you can evolve from
          request-response to streaming/subscription as requirements grow.</li>
        <li><strong>Testing and observability:</strong> Real-time and streaming patterns require advanced monitoring and
          troubleshooting tools; invest in good logging and metrics.</li>
        <li><strong>Security and access control:</strong> Streaming and subscription patterns expose new attack
          surfaces. Ensure proper authentication, authorization, and rate limiting.</li>
        <li><strong>Cost management:</strong> Real-time features (WebSockets, push notifications) can increase
          infrastructure and operational costs; factor this into architecture decisions.</li>
        <li><strong>Scaling considerations:</strong> Subscription-heavy architectures may require advanced pub-sub or
          message broker infrastructure to scale gracefully with concurrent clients.</li>
      </ul>
    </section>

  </main>

  <!-- Footer -->
  <footer class="text-center text-sm text-gray-600 py-4 border-t border-gray-300 mt-10">
    &copy; 2025 Made by <strong>CAMNV</strong>. All rights reserved.
  </footer>
</body>

</html>